/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from '../../../common';

export interface CompounderInterface extends utils.Interface {
  functions: {
    'PERCENT_DIVISOR()': FunctionFragment;
    'addRewardBaseTokens(address[])': FunctionFragment;
    'addressProvider()': FunctionFragment;
    'autocompoundThreshold()': FunctionFragment;
    'baseToken()': FunctionFragment;
    'bountyManager()': FunctionFragment;
    'claimCompound(address,bool)': FunctionFragment;
    'compoundFee()': FunctionFragment;
    'initialize(address,address,address,address,address,uint256,uint256)': FunctionFragment;
    'isEligibleForAutoCompound(address,uint256)': FunctionFragment;
    'isEligibleForCompound(uint256)': FunctionFragment;
    'lastAutocompound(address)': FunctionFragment;
    'lockZap()': FunctionFragment;
    'multiFeeDistribution()': FunctionFragment;
    'owner()': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'priceProvider()': FunctionFragment;
    'rdntToken()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardBaseTokens(uint256)': FunctionFragment;
    'rewardToBaseRoute(address,uint256)': FunctionFragment;
    'selfCompound()': FunctionFragment;
    'selfEligibleCompound()': FunctionFragment;
    'setBountyManager(address)': FunctionFragment;
    'setCompoundFee(uint256)': FunctionFragment;
    'setRoutes(address,address[])': FunctionFragment;
    'setSlippageLimit(uint256)': FunctionFragment;
    'slippageLimit()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'uniRouter()': FunctionFragment;
    'unpause()': FunctionFragment;
    'userEligibleForCompound(address)': FunctionFragment;
    'viewPendingRewards(address)': FunctionFragment;
    'wethToRadiant(uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'PERCENT_DIVISOR'
      | 'addRewardBaseTokens'
      | 'addressProvider'
      | 'autocompoundThreshold'
      | 'baseToken'
      | 'bountyManager'
      | 'claimCompound'
      | 'compoundFee'
      | 'initialize'
      | 'isEligibleForAutoCompound'
      | 'isEligibleForCompound'
      | 'lastAutocompound'
      | 'lockZap'
      | 'multiFeeDistribution'
      | 'owner'
      | 'pause'
      | 'paused'
      | 'priceProvider'
      | 'rdntToken'
      | 'renounceOwnership'
      | 'rewardBaseTokens'
      | 'rewardToBaseRoute'
      | 'selfCompound'
      | 'selfEligibleCompound'
      | 'setBountyManager'
      | 'setCompoundFee'
      | 'setRoutes'
      | 'setSlippageLimit'
      | 'slippageLimit'
      | 'transferOwnership'
      | 'uniRouter'
      | 'unpause'
      | 'userEligibleForCompound'
      | 'viewPendingRewards'
      | 'wethToRadiant'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'PERCENT_DIVISOR', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'addRewardBaseTokens',
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(functionFragment: 'addressProvider', values?: undefined): string;
  encodeFunctionData(functionFragment: 'autocompoundThreshold', values?: undefined): string;
  encodeFunctionData(functionFragment: 'baseToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'bountyManager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'claimCompound',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: 'compoundFee', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'isEligibleForAutoCompound',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'isEligibleForCompound',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'lastAutocompound',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'lockZap', values?: undefined): string;
  encodeFunctionData(functionFragment: 'multiFeeDistribution', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'priceProvider', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rdntToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'rewardBaseTokens',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'rewardToBaseRoute',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'selfCompound', values?: undefined): string;
  encodeFunctionData(functionFragment: 'selfEligibleCompound', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'setBountyManager',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setCompoundFee',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setRoutes',
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'setSlippageLimit',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'slippageLimit', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'uniRouter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'userEligibleForCompound',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'viewPendingRewards',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'wethToRadiant',
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: 'PERCENT_DIVISOR', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addRewardBaseTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addressProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'autocompoundThreshold', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'baseToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bountyManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'compoundFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isEligibleForAutoCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isEligibleForCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastAutocompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lockZap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multiFeeDistribution', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'priceProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rdntToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardBaseTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardToBaseRoute', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfEligibleCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBountyManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setCompoundFee', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRoutes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setSlippageLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'slippageLimit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'uniRouter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userEligibleForCompound', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'viewPendingRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wethToRadiant', data: BytesLike): Result;

  events: {
    'Initialized(uint8)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Paused(address)': EventFragment;
    'RewardBaseTokensUpdated(address[])': EventFragment;
    'RoutesUpdated(address,address[])': EventFragment;
    'Unpaused(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardBaseTokensUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoutesUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RewardBaseTokensUpdatedEventObject {
  _tokens: string[];
}
export type RewardBaseTokensUpdatedEvent = TypedEvent<
  [string[]],
  RewardBaseTokensUpdatedEventObject
>;

export type RewardBaseTokensUpdatedEventFilter = TypedEventFilter<RewardBaseTokensUpdatedEvent>;

export interface RoutesUpdatedEventObject {
  _token: string;
  _routes: string[];
}
export type RoutesUpdatedEvent = TypedEvent<[string, string[]], RoutesUpdatedEventObject>;

export type RoutesUpdatedEventFilter = TypedEventFilter<RoutesUpdatedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface Compounder extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CompounderInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    PERCENT_DIVISOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    addRewardBaseTokens(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<[string]>;

    autocompoundThreshold(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { minStakeAmtEth: BigNumber }>;

    baseToken(overrides?: CallOverrides): Promise<[string]>;

    bountyManager(overrides?: CallOverrides): Promise<[string]>;

    claimCompound(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    compoundFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialize(
      _uniRouter: PromiseOrValue<string>,
      _mfd: PromiseOrValue<string>,
      _baseToken: PromiseOrValue<string>,
      _addressProvider: PromiseOrValue<string>,
      _lockZap: PromiseOrValue<string>,
      _compoundFee: PromiseOrValue<BigNumberish>,
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isEligibleForAutoCompound(
      _user: PromiseOrValue<string>,
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isEligibleForCompound(
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { eligible: boolean }>;

    lastAutocompound(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    lockZap(overrides?: CallOverrides): Promise<[string]>;

    multiFeeDistribution(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    priceProvider(overrides?: CallOverrides): Promise<[string]>;

    rdntToken(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardBaseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    rewardToBaseRoute(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    selfCompound(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    selfEligibleCompound(overrides?: CallOverrides): Promise<[boolean] & { eligible: boolean }>;

    setBountyManager(
      _manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCompoundFee(
      _compoundFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRoutes(
      _token: PromiseOrValue<string>,
      _routes: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSlippageLimit(
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slippageLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    uniRouter(overrides?: CallOverrides): Promise<[string]>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userEligibleForCompound(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { eligible: boolean }>;

    viewPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], BigNumber[]] & { tokens: string[]; amts: BigNumber[] }>;

    wethToRadiant(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;
  };

  PERCENT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

  addRewardBaseTokens(
    _tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addressProvider(overrides?: CallOverrides): Promise<string>;

  autocompoundThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  baseToken(overrides?: CallOverrides): Promise<string>;

  bountyManager(overrides?: CallOverrides): Promise<string>;

  claimCompound(
    _user: PromiseOrValue<string>,
    _execute: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  compoundFee(overrides?: CallOverrides): Promise<BigNumber>;

  initialize(
    _uniRouter: PromiseOrValue<string>,
    _mfd: PromiseOrValue<string>,
    _baseToken: PromiseOrValue<string>,
    _addressProvider: PromiseOrValue<string>,
    _lockZap: PromiseOrValue<string>,
    _compoundFee: PromiseOrValue<BigNumberish>,
    _slippageLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isEligibleForAutoCompound(
    _user: PromiseOrValue<string>,
    _pending: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isEligibleForCompound(
    _pending: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lastAutocompound(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  lockZap(overrides?: CallOverrides): Promise<string>;

  multiFeeDistribution(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  priceProvider(overrides?: CallOverrides): Promise<string>;

  rdntToken(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardBaseTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  rewardToBaseRoute(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  selfCompound(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  selfEligibleCompound(overrides?: CallOverrides): Promise<boolean>;

  setBountyManager(
    _manager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCompoundFee(
    _compoundFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRoutes(
    _token: PromiseOrValue<string>,
    _routes: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSlippageLimit(
    _slippageLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slippageLimit(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  uniRouter(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  userEligibleForCompound(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  viewPendingRewards(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[string[], BigNumber[]] & { tokens: string[]; amts: BigNumber[] }>;

  wethToRadiant(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  callStatic: {
    PERCENT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    addRewardBaseTokens(
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    addressProvider(overrides?: CallOverrides): Promise<string>;

    autocompoundThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<string>;

    bountyManager(overrides?: CallOverrides): Promise<string>;

    claimCompound(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    compoundFee(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _uniRouter: PromiseOrValue<string>,
      _mfd: PromiseOrValue<string>,
      _baseToken: PromiseOrValue<string>,
      _addressProvider: PromiseOrValue<string>,
      _lockZap: PromiseOrValue<string>,
      _compoundFee: PromiseOrValue<BigNumberish>,
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isEligibleForAutoCompound(
      _user: PromiseOrValue<string>,
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isEligibleForCompound(
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastAutocompound(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockZap(overrides?: CallOverrides): Promise<string>;

    multiFeeDistribution(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    priceProvider(overrides?: CallOverrides): Promise<string>;

    rdntToken(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardBaseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    rewardToBaseRoute(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    selfCompound(overrides?: CallOverrides): Promise<BigNumber>;

    selfEligibleCompound(overrides?: CallOverrides): Promise<boolean>;

    setBountyManager(_manager: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setCompoundFee(
      _compoundFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRoutes(
      _token: PromiseOrValue<string>,
      _routes: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setSlippageLimit(
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    slippageLimit(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    uniRouter(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    userEligibleForCompound(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    viewPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[], BigNumber[]] & { tokens: string[]; amts: BigNumber[] }>;

    wethToRadiant(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'RewardBaseTokensUpdated(address[])'(_tokens?: null): RewardBaseTokensUpdatedEventFilter;
    RewardBaseTokensUpdated(_tokens?: null): RewardBaseTokensUpdatedEventFilter;

    'RoutesUpdated(address,address[])'(_token?: null, _routes?: null): RoutesUpdatedEventFilter;
    RoutesUpdated(_token?: null, _routes?: null): RoutesUpdatedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    PERCENT_DIVISOR(overrides?: CallOverrides): Promise<BigNumber>;

    addRewardBaseTokens(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addressProvider(overrides?: CallOverrides): Promise<BigNumber>;

    autocompoundThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    baseToken(overrides?: CallOverrides): Promise<BigNumber>;

    bountyManager(overrides?: CallOverrides): Promise<BigNumber>;

    claimCompound(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    compoundFee(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _uniRouter: PromiseOrValue<string>,
      _mfd: PromiseOrValue<string>,
      _baseToken: PromiseOrValue<string>,
      _addressProvider: PromiseOrValue<string>,
      _lockZap: PromiseOrValue<string>,
      _compoundFee: PromiseOrValue<BigNumberish>,
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isEligibleForAutoCompound(
      _user: PromiseOrValue<string>,
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isEligibleForCompound(
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastAutocompound(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lockZap(overrides?: CallOverrides): Promise<BigNumber>;

    multiFeeDistribution(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    priceProvider(overrides?: CallOverrides): Promise<BigNumber>;

    rdntToken(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardBaseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rewardToBaseRoute(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    selfCompound(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    selfEligibleCompound(overrides?: CallOverrides): Promise<BigNumber>;

    setBountyManager(
      _manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCompoundFee(
      _compoundFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRoutes(
      _token: PromiseOrValue<string>,
      _routes: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSlippageLimit(
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slippageLimit(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    uniRouter(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    userEligibleForCompound(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    wethToRadiant(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    PERCENT_DIVISOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addRewardBaseTokens(
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addressProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    autocompoundThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bountyManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimCompound(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    compoundFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _uniRouter: PromiseOrValue<string>,
      _mfd: PromiseOrValue<string>,
      _baseToken: PromiseOrValue<string>,
      _addressProvider: PromiseOrValue<string>,
      _lockZap: PromiseOrValue<string>,
      _compoundFee: PromiseOrValue<BigNumberish>,
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isEligibleForAutoCompound(
      _user: PromiseOrValue<string>,
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isEligibleForCompound(
      _pending: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastAutocompound(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lockZap(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multiFeeDistribution(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rdntToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardBaseTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rewardToBaseRoute(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    selfCompound(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    selfEligibleCompound(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setBountyManager(
      _manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCompoundFee(
      _compoundFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRoutes(
      _token: PromiseOrValue<string>,
      _routes: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSlippageLimit(
      _slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slippageLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    uniRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userEligibleForCompound(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    wethToRadiant(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}

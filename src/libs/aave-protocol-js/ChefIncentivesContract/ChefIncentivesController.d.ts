/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from '../../../common';

export interface ChefIncentivesControllerInterface extends utils.Interface {
  functions: {
    'ELIGIBILITY_ENABLED()': FunctionFragment;
    'accountedRewards()': FunctionFragment;
    'addPool(address,uint256)': FunctionFragment;
    'afterLockUpdate(address)': FunctionFragment;
    'allPendingRewards(address)': FunctionFragment;
    'batchUpdateAllocPoint(address[],uint256[])': FunctionFragment;
    'beforeLockUpdate(address)': FunctionFragment;
    'bountyManager()': FunctionFragment;
    'claim(address,address[])': FunctionFragment;
    'claimAll(address)': FunctionFragment;
    'claimBounty(address,bool)': FunctionFragment;
    'claimToBase(address,address[])': FunctionFragment;
    'depositedRewards()': FunctionFragment;
    'eligibilityExempt(address)': FunctionFragment;
    'eligibleDataProvider()': FunctionFragment;
    'emissionSchedule(uint256)': FunctionFragment;
    'emissionScheduleIndex()': FunctionFragment;
    'endRewardTime()': FunctionFragment;
    'handleActionAfter(address,uint256,uint256)': FunctionFragment;
    'handleActionBefore(address)': FunctionFragment;
    'initialize(address,address,address,uint256)': FunctionFragment;
    'lastAllPoolUpdate()': FunctionFragment;
    'lastRPS()': FunctionFragment;
    'owner()': FunctionFragment;
    'paused()': FunctionFragment;
    'pendingRewards(address,address[])': FunctionFragment;
    'persistRewardsPerSecond()': FunctionFragment;
    'poolConfigurator()': FunctionFragment;
    'poolInfo(address)': FunctionFragment;
    'poolLength()': FunctionFragment;
    'recoverERC20(address,uint256)': FunctionFragment;
    'registerRewardDeposit(uint256)': FunctionFragment;
    'registeredTokens(uint256)': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rewardMinter()': FunctionFragment;
    'rewardsPerSecond()': FunctionFragment;
    'saveUserRewards(address[])': FunctionFragment;
    'setBountyManager(address)': FunctionFragment;
    'setEligibilityEnabled(bool)': FunctionFragment;
    'setEligibilityExempt(address)': FunctionFragment;
    'setEmissionSchedule(uint256[],uint256[])': FunctionFragment;
    'setOnwardIncentives(address,address)': FunctionFragment;
    'setRewardsPerSecond(uint256,bool)': FunctionFragment;
    'start()': FunctionFragment;
    'startTime()': FunctionFragment;
    'totalAllocPoint()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'userBaseClaimable(address)': FunctionFragment;
    'userInfo(address,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'ELIGIBILITY_ENABLED'
      | 'accountedRewards'
      | 'addPool'
      | 'afterLockUpdate'
      | 'allPendingRewards'
      | 'batchUpdateAllocPoint'
      | 'beforeLockUpdate'
      | 'bountyManager'
      | 'claim'
      | 'claimAll'
      | 'claimBounty'
      | 'claimToBase'
      | 'depositedRewards'
      | 'eligibilityExempt'
      | 'eligibleDataProvider'
      | 'emissionSchedule'
      | 'emissionScheduleIndex'
      | 'endRewardTime'
      | 'handleActionAfter'
      | 'handleActionBefore'
      | 'initialize'
      | 'lastAllPoolUpdate'
      | 'lastRPS'
      | 'owner'
      | 'paused'
      | 'pendingRewards'
      | 'persistRewardsPerSecond'
      | 'poolConfigurator'
      | 'poolInfo'
      | 'poolLength'
      | 'recoverERC20'
      | 'registerRewardDeposit'
      | 'registeredTokens'
      | 'renounceOwnership'
      | 'rewardMinter'
      | 'rewardsPerSecond'
      | 'saveUserRewards'
      | 'setBountyManager'
      | 'setEligibilityEnabled'
      | 'setEligibilityExempt'
      | 'setEmissionSchedule'
      | 'setOnwardIncentives'
      | 'setRewardsPerSecond'
      | 'start'
      | 'startTime'
      | 'totalAllocPoint'
      | 'transferOwnership'
      | 'userBaseClaimable'
      | 'userInfo'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'ELIGIBILITY_ENABLED', values?: undefined): string;
  encodeFunctionData(functionFragment: 'accountedRewards', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'addPool',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'afterLockUpdate', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'allPendingRewards',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'batchUpdateAllocPoint',
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'beforeLockUpdate',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'bountyManager', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'claim',
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(functionFragment: 'claimAll', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: 'claimBounty',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'claimToBase',
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(functionFragment: 'depositedRewards', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'eligibilityExempt',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'eligibleDataProvider', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'emissionSchedule',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'emissionScheduleIndex', values?: undefined): string;
  encodeFunctionData(functionFragment: 'endRewardTime', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'handleActionAfter',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'handleActionBefore',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: 'lastAllPoolUpdate', values?: undefined): string;
  encodeFunctionData(functionFragment: 'lastRPS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'pendingRewards',
    values: [PromiseOrValue<string>, PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(functionFragment: 'persistRewardsPerSecond', values?: undefined): string;
  encodeFunctionData(functionFragment: 'poolConfigurator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'poolInfo', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'poolLength', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'recoverERC20',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'registerRewardDeposit',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'registeredTokens',
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardMinter', values?: undefined): string;
  encodeFunctionData(functionFragment: 'rewardsPerSecond', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'saveUserRewards',
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'setBountyManager',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEligibilityEnabled',
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEligibilityExempt',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setEmissionSchedule',
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'setOnwardIncentives',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'setRewardsPerSecond',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: 'start', values?: undefined): string;
  encodeFunctionData(functionFragment: 'startTime', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalAllocPoint', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'userBaseClaimable',
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: 'userInfo',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: 'ELIGIBILITY_ENABLED', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'accountedRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'afterLockUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allPendingRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'batchUpdateAllocPoint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'beforeLockUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bountyManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claim', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimAll', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimBounty', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimToBase', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositedRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'eligibilityExempt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'eligibleDataProvider', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emissionSchedule', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'emissionScheduleIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'endRewardTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'handleActionAfter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'handleActionBefore', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastAllPoolUpdate', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lastRPS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pendingRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'persistRewardsPerSecond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolConfigurator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolInfo', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'poolLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'recoverERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registerRewardDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'registeredTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardMinter', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rewardsPerSecond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'saveUserRewards', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setBountyManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEligibilityEnabled', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEligibilityExempt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setEmissionSchedule', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setOnwardIncentives', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setRewardsPerSecond', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'start', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startTime', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalAllocPoint', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userBaseClaimable', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userInfo', data: BytesLike): Result;

  events: {
    'BalanceUpdated(address,address,uint256,uint256)': EventFragment;
    'ChefReserveEmpty(uint256)': EventFragment;
    'ChefReserveLow(uint256)': EventFragment;
    'Disqualified(address)': EventFragment;
    'EmissionScheduleAppended(uint256[],uint256[])': EventFragment;
    'Initialized(uint8)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Paused(address)': EventFragment;
    'RewardsPerSecondUpdated(uint256,bool)': EventFragment;
    'Unpaused(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'BalanceUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ChefReserveEmpty'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ChefReserveLow'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Disqualified'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'EmissionScheduleAppended'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RewardsPerSecondUpdated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface BalanceUpdatedEventObject {
  token: string;
  user: string;
  balance: BigNumber;
  totalSupply: BigNumber;
}
export type BalanceUpdatedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  BalanceUpdatedEventObject
>;

export type BalanceUpdatedEventFilter = TypedEventFilter<BalanceUpdatedEvent>;

export interface ChefReserveEmptyEventObject {
  _balance: BigNumber;
}
export type ChefReserveEmptyEvent = TypedEvent<[BigNumber], ChefReserveEmptyEventObject>;

export type ChefReserveEmptyEventFilter = TypedEventFilter<ChefReserveEmptyEvent>;

export interface ChefReserveLowEventObject {
  _balance: BigNumber;
}
export type ChefReserveLowEvent = TypedEvent<[BigNumber], ChefReserveLowEventObject>;

export type ChefReserveLowEventFilter = TypedEventFilter<ChefReserveLowEvent>;

export interface DisqualifiedEventObject {
  user: string;
}
export type DisqualifiedEvent = TypedEvent<[string], DisqualifiedEventObject>;

export type DisqualifiedEventFilter = TypedEventFilter<DisqualifiedEvent>;

export interface EmissionScheduleAppendedEventObject {
  startTimeOffsets: BigNumber[];
  rewardsPerSeconds: BigNumber[];
}
export type EmissionScheduleAppendedEvent = TypedEvent<
  [BigNumber[], BigNumber[]],
  EmissionScheduleAppendedEventObject
>;

export type EmissionScheduleAppendedEventFilter = TypedEventFilter<EmissionScheduleAppendedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RewardsPerSecondUpdatedEventObject {
  rewardsPerSecond: BigNumber;
  persist: boolean;
}
export type RewardsPerSecondUpdatedEvent = TypedEvent<
  [BigNumber, boolean],
  RewardsPerSecondUpdatedEventObject
>;

export type RewardsPerSecondUpdatedEventFilter = TypedEventFilter<RewardsPerSecondUpdatedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface ChefIncentivesController extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ChefIncentivesControllerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ELIGIBILITY_ENABLED(overrides?: CallOverrides): Promise<[boolean]>;

    accountedRewards(overrides?: CallOverrides): Promise<[BigNumber]>;

    addPool(
      _token: PromiseOrValue<string>,
      _allocPoint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    afterLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    allPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { pending: BigNumber }>;

    batchUpdateAllocPoint(
      _tokens: PromiseOrValue<string>[],
      _allocPoints: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    beforeLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    bountyManager(overrides?: CallOverrides): Promise<[string]>;

    claim(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimAll(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimBounty(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimToBase(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositedRewards(overrides?: CallOverrides): Promise<[BigNumber]>;

    eligibilityExempt(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    eligibleDataProvider(overrides?: CallOverrides): Promise<[string]>;

    emissionSchedule(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        startTimeOffset: BigNumber;
        rewardsPerSecond: BigNumber;
      }
    >;

    emissionScheduleIndex(overrides?: CallOverrides): Promise<[BigNumber]>;

    endRewardTime(overrides?: CallOverrides): Promise<[BigNumber] & { timestamp: BigNumber }>;

    handleActionAfter(
      _user: PromiseOrValue<string>,
      _balance: PromiseOrValue<BigNumberish>,
      _totalSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    handleActionBefore(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _poolConfigurator: PromiseOrValue<string>,
      _eligibleDataProvider: PromiseOrValue<string>,
      _rewardMinter: PromiseOrValue<string>,
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lastAllPoolUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastRPS(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingRewards(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    persistRewardsPerSecond(overrides?: CallOverrides): Promise<[boolean]>;

    poolConfigurator(overrides?: CallOverrides): Promise<[string]>;

    poolInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string] & {
        totalSupply: BigNumber;
        allocPoint: BigNumber;
        lastRewardTime: BigNumber;
        accRewardPerShare: BigNumber;
        onwardIncentives: string;
      }
    >;

    poolLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerRewardDeposit(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registeredTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardMinter(overrides?: CallOverrides): Promise<[string]>;

    rewardsPerSecond(overrides?: CallOverrides): Promise<[BigNumber]>;

    saveUserRewards(
      _users: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBountyManager(
      _bountyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setEligibilityEnabled(
      _newVal: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setEligibilityExempt(
      _contract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setEmissionSchedule(
      _startTimeOffsets: PromiseOrValue<BigNumberish>[],
      _rewardsPerSecond: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOnwardIncentives(
      _token: PromiseOrValue<string>,
      _incentives: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRewardsPerSecond(
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      _persist: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    startTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalAllocPoint(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userBaseClaimable(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        rewardDebt: BigNumber;
        enterTime: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;
  };

  ELIGIBILITY_ENABLED(overrides?: CallOverrides): Promise<boolean>;

  accountedRewards(overrides?: CallOverrides): Promise<BigNumber>;

  addPool(
    _token: PromiseOrValue<string>,
    _allocPoint: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  afterLockUpdate(
    _user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  allPendingRewards(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  batchUpdateAllocPoint(
    _tokens: PromiseOrValue<string>[],
    _allocPoints: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  beforeLockUpdate(
    _user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  bountyManager(overrides?: CallOverrides): Promise<string>;

  claim(
    _user: PromiseOrValue<string>,
    _tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimAll(
    _user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimBounty(
    _user: PromiseOrValue<string>,
    _execute: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimToBase(
    _user: PromiseOrValue<string>,
    _tokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositedRewards(overrides?: CallOverrides): Promise<BigNumber>;

  eligibilityExempt(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  eligibleDataProvider(overrides?: CallOverrides): Promise<string>;

  emissionSchedule(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      startTimeOffset: BigNumber;
      rewardsPerSecond: BigNumber;
    }
  >;

  emissionScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

  endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

  handleActionAfter(
    _user: PromiseOrValue<string>,
    _balance: PromiseOrValue<BigNumberish>,
    _totalSupply: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  handleActionBefore(
    _user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _poolConfigurator: PromiseOrValue<string>,
    _eligibleDataProvider: PromiseOrValue<string>,
    _rewardMinter: PromiseOrValue<string>,
    _rewardsPerSecond: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lastAllPoolUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  lastRPS(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingRewards(
    _user: PromiseOrValue<string>,
    _tokens: PromiseOrValue<string>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  persistRewardsPerSecond(overrides?: CallOverrides): Promise<boolean>;

  poolConfigurator(overrides?: CallOverrides): Promise<string>;

  poolInfo(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, string] & {
      totalSupply: BigNumber;
      allocPoint: BigNumber;
      lastRewardTime: BigNumber;
      accRewardPerShare: BigNumber;
      onwardIncentives: string;
    }
  >;

  poolLength(overrides?: CallOverrides): Promise<BigNumber>;

  recoverERC20(
    tokenAddress: PromiseOrValue<string>,
    tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerRewardDeposit(
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registeredTokens(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardMinter(overrides?: CallOverrides): Promise<string>;

  rewardsPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

  saveUserRewards(
    _users: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBountyManager(
    _bountyManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setEligibilityEnabled(
    _newVal: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setEligibilityExempt(
    _contract: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setEmissionSchedule(
    _startTimeOffsets: PromiseOrValue<BigNumberish>[],
    _rewardsPerSecond: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOnwardIncentives(
    _token: PromiseOrValue<string>,
    _incentives: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRewardsPerSecond(
    _rewardsPerSecond: PromiseOrValue<BigNumberish>,
    _persist: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  startTime(overrides?: CallOverrides): Promise<BigNumber>;

  totalAllocPoint(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  userBaseClaimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  userInfo(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      amount: BigNumber;
      rewardDebt: BigNumber;
      enterTime: BigNumber;
      lastClaimTime: BigNumber;
    }
  >;

  callStatic: {
    ELIGIBILITY_ENABLED(overrides?: CallOverrides): Promise<boolean>;

    accountedRewards(overrides?: CallOverrides): Promise<BigNumber>;

    addPool(
      _token: PromiseOrValue<string>,
      _allocPoint: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    afterLockUpdate(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    allPendingRewards(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    batchUpdateAllocPoint(
      _tokens: PromiseOrValue<string>[],
      _allocPoints: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    beforeLockUpdate(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    bountyManager(overrides?: CallOverrides): Promise<string>;

    claim(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    claimAll(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    claimBounty(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    claimToBase(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    depositedRewards(overrides?: CallOverrides): Promise<BigNumber>;

    eligibilityExempt(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    eligibleDataProvider(overrides?: CallOverrides): Promise<string>;

    emissionSchedule(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        startTimeOffset: BigNumber;
        rewardsPerSecond: BigNumber;
      }
    >;

    emissionScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

    endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    handleActionAfter(
      _user: PromiseOrValue<string>,
      _balance: PromiseOrValue<BigNumberish>,
      _totalSupply: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    handleActionBefore(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    initialize(
      _poolConfigurator: PromiseOrValue<string>,
      _eligibleDataProvider: PromiseOrValue<string>,
      _rewardMinter: PromiseOrValue<string>,
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    lastAllPoolUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lastRPS(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingRewards(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    persistRewardsPerSecond(overrides?: CallOverrides): Promise<boolean>;

    poolConfigurator(overrides?: CallOverrides): Promise<string>;

    poolInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string] & {
        totalSupply: BigNumber;
        allocPoint: BigNumber;
        lastRewardTime: BigNumber;
        accRewardPerShare: BigNumber;
        onwardIncentives: string;
      }
    >;

    poolLength(overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerRewardDeposit(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    registeredTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardMinter(overrides?: CallOverrides): Promise<string>;

    rewardsPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    saveUserRewards(_users: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    setBountyManager(
      _bountyManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setEligibilityEnabled(
      _newVal: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setEligibilityExempt(
      _contract: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setEmissionSchedule(
      _startTimeOffsets: PromiseOrValue<BigNumberish>[],
      _rewardsPerSecond: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setOnwardIncentives(
      _token: PromiseOrValue<string>,
      _incentives: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRewardsPerSecond(
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      _persist: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    start(overrides?: CallOverrides): Promise<void>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    totalAllocPoint(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    userBaseClaimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        rewardDebt: BigNumber;
        enterTime: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;
  };

  filters: {
    'BalanceUpdated(address,address,uint256,uint256)'(
      token?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      balance?: null,
      totalSupply?: null
    ): BalanceUpdatedEventFilter;
    BalanceUpdated(
      token?: PromiseOrValue<string> | null,
      user?: PromiseOrValue<string> | null,
      balance?: null,
      totalSupply?: null
    ): BalanceUpdatedEventFilter;

    'ChefReserveEmpty(uint256)'(_balance?: null): ChefReserveEmptyEventFilter;
    ChefReserveEmpty(_balance?: null): ChefReserveEmptyEventFilter;

    'ChefReserveLow(uint256)'(_balance?: null): ChefReserveLowEventFilter;
    ChefReserveLow(_balance?: null): ChefReserveLowEventFilter;

    'Disqualified(address)'(user?: PromiseOrValue<string> | null): DisqualifiedEventFilter;
    Disqualified(user?: PromiseOrValue<string> | null): DisqualifiedEventFilter;

    'EmissionScheduleAppended(uint256[],uint256[])'(
      startTimeOffsets?: null,
      rewardsPerSeconds?: null
    ): EmissionScheduleAppendedEventFilter;
    EmissionScheduleAppended(
      startTimeOffsets?: null,
      rewardsPerSeconds?: null
    ): EmissionScheduleAppendedEventFilter;

    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'RewardsPerSecondUpdated(uint256,bool)'(
      rewardsPerSecond?: PromiseOrValue<BigNumberish> | null,
      persist?: null
    ): RewardsPerSecondUpdatedEventFilter;
    RewardsPerSecondUpdated(
      rewardsPerSecond?: PromiseOrValue<BigNumberish> | null,
      persist?: null
    ): RewardsPerSecondUpdatedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    ELIGIBILITY_ENABLED(overrides?: CallOverrides): Promise<BigNumber>;

    accountedRewards(overrides?: CallOverrides): Promise<BigNumber>;

    addPool(
      _token: PromiseOrValue<string>,
      _allocPoint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    afterLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    allPendingRewards(_user: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    batchUpdateAllocPoint(
      _tokens: PromiseOrValue<string>[],
      _allocPoints: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    beforeLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    bountyManager(overrides?: CallOverrides): Promise<BigNumber>;

    claim(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimAll(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimBounty(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimToBase(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositedRewards(overrides?: CallOverrides): Promise<BigNumber>;

    eligibilityExempt(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    eligibleDataProvider(overrides?: CallOverrides): Promise<BigNumber>;

    emissionSchedule(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    emissionScheduleIndex(overrides?: CallOverrides): Promise<BigNumber>;

    endRewardTime(overrides?: CallOverrides): Promise<BigNumber>;

    handleActionAfter(
      _user: PromiseOrValue<string>,
      _balance: PromiseOrValue<BigNumberish>,
      _totalSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    handleActionBefore(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      _poolConfigurator: PromiseOrValue<string>,
      _eligibleDataProvider: PromiseOrValue<string>,
      _rewardMinter: PromiseOrValue<string>,
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lastAllPoolUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    lastRPS(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRewards(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    persistRewardsPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    poolConfigurator(overrides?: CallOverrides): Promise<BigNumber>;

    poolInfo(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    poolLength(overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerRewardDeposit(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registeredTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardMinter(overrides?: CallOverrides): Promise<BigNumber>;

    rewardsPerSecond(overrides?: CallOverrides): Promise<BigNumber>;

    saveUserRewards(
      _users: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBountyManager(
      _bountyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setEligibilityEnabled(
      _newVal: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setEligibilityExempt(
      _contract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setEmissionSchedule(
      _startTimeOffsets: PromiseOrValue<BigNumberish>[],
      _rewardsPerSecond: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOnwardIncentives(
      _token: PromiseOrValue<string>,
      _incentives: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRewardsPerSecond(
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      _persist: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    startTime(overrides?: CallOverrides): Promise<BigNumber>;

    totalAllocPoint(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    userBaseClaimable(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ELIGIBILITY_ENABLED(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    accountedRewards(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addPool(
      _token: PromiseOrValue<string>,
      _allocPoint: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    afterLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    allPendingRewards(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchUpdateAllocPoint(
      _tokens: PromiseOrValue<string>[],
      _allocPoints: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    beforeLockUpdate(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    bountyManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claim(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimAll(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimBounty(
      _user: PromiseOrValue<string>,
      _execute: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimToBase(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositedRewards(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eligibilityExempt(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eligibleDataProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    emissionSchedule(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    emissionScheduleIndex(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    endRewardTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    handleActionAfter(
      _user: PromiseOrValue<string>,
      _balance: PromiseOrValue<BigNumberish>,
      _totalSupply: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    handleActionBefore(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _poolConfigurator: PromiseOrValue<string>,
      _eligibleDataProvider: PromiseOrValue<string>,
      _rewardMinter: PromiseOrValue<string>,
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lastAllPoolUpdate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastRPS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingRewards(
      _user: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    persistRewardsPerSecond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolConfigurator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolInfo(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverERC20(
      tokenAddress: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerRewardDeposit(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registeredTokens(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardMinter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardsPerSecond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    saveUserRewards(
      _users: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBountyManager(
      _bountyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setEligibilityEnabled(
      _newVal: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setEligibilityExempt(
      _contract: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setEmissionSchedule(
      _startTimeOffsets: PromiseOrValue<BigNumberish>[],
      _rewardsPerSecond: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOnwardIncentives(
      _token: PromiseOrValue<string>,
      _incentives: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRewardsPerSecond(
      _rewardsPerSecond: PromiseOrValue<BigNumberish>,
      _persist: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    start(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    startTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalAllocPoint(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userBaseClaimable(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
